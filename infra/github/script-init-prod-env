#!/bin/bash

# Script d'installation de l'environnement de production
# Utilise Minikube avec driver Docker + tunnel automatis√©

# Demander le nom de domaine Azure
echo "======================================"
echo "Initialisation environnement PROD"
echo "======================================"
echo ""
read -p "Entrez le nom DNS de votre VM Azure (ex: simon-vm.francecentral.cloudapp.azure.com): " AZURE_DNS
if [ -z "$AZURE_DNS" ]; then
    echo "ERREUR: Le nom DNS est obligatoire"
    exit 1
fi

echo "‚úì Nom DNS configur√©: $AZURE_DNS"
echo ""

# V√©rifier et installer Docker
if ! command -v docker &> /dev/null; then
    echo "Installation de Docker (n√©cessite sudo)..."
    curl -fsSL https://get.docker.com -o get-docker.sh
    sudo sh get-docker.sh
    rm get-docker.sh
    echo "Docker install√©."
fi

# Ajouter l'utilisateur au groupe docker si n√©cessaire
if ! groups | grep -q docker; then
    echo "Ajout de l'utilisateur au groupe docker (n√©cessite sudo)..."
    sudo usermod -aG docker $USER
    echo "‚ö†Ô∏è  Vous devez vous d√©connecter/reconnecter ou ex√©cuter: newgrp docker"
    echo "   Puis relancer ce script"
    exit 0
fi

echo ""

# Installer kubectl si non pr√©sent
if ! command -v kubectl &> /dev/null; then
    echo "Installation de kubectl (n√©cessite sudo)..."
    curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
    rm kubectl
    echo "kubectl install√©."
fi

# Installer minikube si non pr√©sent
if ! command -v minikube &> /dev/null; then
    echo "Installation de minikube (n√©cessite sudo)..."
    curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
    sudo install minikube-linux-amd64 /usr/local/bin/minikube
    rm minikube-linux-amd64
    echo "Minikube install√©."
fi

# D√©marrer minikube avec le driver Docker
echo "D√©marrage de minikube..."
echo "‚è±Ô∏è  Cela peut prendre quelques minutes..."
echo "Configuration : 3 CPUs / 10 GB RAM / Driver Docker"

minikube start \
  --driver=docker \
  --cpus=3 \
  --memory=10240 \
  --wait=all \
  --wait-timeout=10m

echo "‚úì Minikube d√©marr√© avec succ√®s"

# Configurer kubectl pour utiliser minikube
export KUBECONFIG=~/.kube/config
minikube update-context

# Installer Helm si non pr√©sent
if ! command -v helm &> /dev/null; then
    echo "Installation de Helm (n√©cessite sudo)..."
    curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | sudo bash
    echo "Helm install√©."
fi

# Ajouter les repos Helm n√©cessaires
helm repo add argo https://argoproj.github.io/argo-helm
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
helm repo update

# Cr√©er namespaces
kubectl create namespace argocd
kubectl create namespace ingress-nginx
kubectl create namespace monitoring
kubectl create namespace simon-prod

# Installer nginx-ingress controller avec hostNetwork
echo "======================================"
echo "Installation de nginx-ingress"
echo "======================================"
echo ""

helm install ingress-nginx ingress-nginx/ingress-nginx \
  \
  --namespace ingress-nginx \
  --set controller.hostNetwork=true \
  --set controller.kind=DaemonSet \
  --set controller.service.type=ClusterIP \
  --wait \
  --timeout 5m

echo "‚úì nginx-ingress install√© (hostNetwork - ports 80 et 443 directement sur l'h√¥te)"
echo ""

# Attendre que nginx soit pr√™t
kubectl wait --namespace ingress-nginx \
  --for=condition=ready pod \
  --selector=app.kubernetes.io/component=controller \
  --timeout=120s

echo "‚úì nginx-ingress pr√™t et accessible sur les ports 80 et 443 de la VM"
echo ""

# Installer ArgoCD via Helm
echo "======================================"
echo "Installation d'ArgoCD"
echo "======================================"
echo ""

helm install argocd argo/argo-cd \
  \
  --namespace argocd \
  --set server.service.type=ClusterIP \
  --set server.insecure=true \
  --set 'server.extraArgs={--basehref=/argocd,--rootpath=/argocd}' \
  --wait

echo "‚úì ArgoCD install√©"
echo ""

# Installer ArgoCD Image Updater via Helm
helm install argocd-image-updater argo/argocd-image-updater \
  \
  --namespace argocd \
  --wait

# R√©cup√©rer le mot de passe admin initial d'ArgoCD
ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
echo "ArgoCD install√©. Mot de passe admin initial:"
echo "$ARGOCD_PASSWORD"
echo ""

# Configurer ArgoCD Image Updater pour surveiller les registres d'images
echo "======================================"
echo "Configuration d'ArgoCD Image Updater"
echo "======================================"
echo ""

# Cr√©er une ConfigMap pour configurer les registres √† surveiller
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-image-updater-config
  namespace: argocd
data:
  # Liste des registres √† surveiller (Docker Hub par d√©faut)
  registries.conf: |
    registries:
    - name: Docker Hub
      api_url: https://registry-1.docker.io
      ping: yes
      credentials: pullsecret:argocd/dockerhub-secret
      default: yes
EOF

echo "‚úì Configuration du registry pour Image Updater"
echo ""
echo "‚ö†Ô∏è  IMPORTANT: Pour que l'Image Updater puisse surveiller vos images:"
echo "   1. Cr√©ez un secret pour vos credentials Docker Hub (si images priv√©es):"
echo "      kubectl create secret docker-registry dockerhub-secret \\"
echo "        --docker-server=https://registry-1.docker.io \\"
echo "        --docker-username=<username> \\"
echo "        --docker-password=<password> \\"
echo "        --docker-email=<email> \\"
echo "        -n argocd"
echo ""
echo "   2. Dans vos Applications ArgoCD, ajoutez ces annotations:"
echo "      argocd-image-updater.argoproj.io/image-list: <nom-image>:<registry>/<image>:<version>"
echo "      argocd-image-updater.argoproj.io/update-strategy: semver"
echo ""
echo "   Exemple pour une API:"
echo "      argocd-image-updater.argoproj.io/image-list: api-capteur=dockerhub/simon/api-capteur:~1.0"
echo "      argocd-image-updater.argoproj.io/update-strategy: semver"
echo ""


# Cr√©er namespaces pour monitoring et applications
kubectl create namespace monitoring || true
kubectl create namespace simon-prod || true

# Installer Prometheus via Helm
echo "======================================"
echo "Installation de Prometheus"
echo "======================================"
echo ""

helm install prometheus prometheus-community/kube-prometheus-stack \
  \
  --namespace monitoring \
  --set prometheus.service.type=ClusterIP \
  --set grafana.service.type=ClusterIP \
  --set grafana.adminPassword=admin \
  --wait

echo "‚úì Prometheus et Grafana install√©s"
echo ""

# Cr√©er les ressources Ingress
echo "======================================"
echo "Configuration des Ingress"
echo "======================================"
echo ""

# Cr√©er un dossier temporaire pour les manifests
mkdir -p /tmp/k8s-manifests

# Cr√©er le dossier ingress dans prod si n√©cessaire
mkdir -p prod/ingress

# Ingress pour ArgoCD
cat > prod/ingress/argocd.yaml <<EOF
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: argocd-server-ingress
  namespace: argocd
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
    nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
spec:
  ingressClassName: nginx
  rules:
  - host: ${AZURE_DNS}
    http:
      paths:
      - path: /argocd
        pathType: Prefix
        backend:
          service:
            name: argocd-server
            port:
              number: 80
EOF

# Attendre que le webhook nginx soit pr√™t
echo "‚è±Ô∏è  Attente du webhook nginx-ingress (30 secondes)..."
sleep 30

# Appliquer l'Ingress ArgoCD
kubectl apply -f prod/ingress/argocd.yaml

# Ingress pour Prometheus
cat > prod/ingress/prometheus.yaml <<EOF
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: prometheus-ingress
  namespace: monitoring
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
spec:
  ingressClassName: nginx
  rules:
  - host: ${AZURE_DNS}
    http:
      paths:
      - path: /prometheus
        pathType: Prefix
        backend:
          service:
            name: prometheus-kube-prometheus-prometheus
            port:
              number: 9090
EOF

# Appliquer l'Ingress Prometheus
kubectl apply -f prod/ingress/prometheus.yaml

# Ingress pour Grafana
cat > prod/ingress/grafana.yaml <<EOF
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: grafana-ingress
  namespace: monitoring
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
spec:
  ingressClassName: nginx
  rules:
  - host: ${AZURE_DNS}
    http:
      paths:
      - path: /grafana
        pathType: Prefix
        backend:
          service:
            name: prometheus-grafana
            port:
              number: 80
EOF

# Appliquer l'Ingress Grafana
kubectl apply -f prod/ingress/grafana.yaml

# Configurer Grafana pour fonctionner sous /grafana
kubectl set env deployment/prometheus-grafana \
  -n monitoring \
  GF_SERVER_ROOT_URL="http://${AZURE_DNS}/grafana" \
  GF_SERVER_SERVE_FROM_SUB_PATH="true"

# Ingress pour le Frontend
cat > prod/ingress/frontend.yaml <<EOF
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: frontend-ingress
  namespace: simon-prod
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
spec:
  ingressClassName: nginx
  rules:
  - host: ${AZURE_DNS}
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend-service
            port:
              number: 80
EOF

# Ingress pour l'API Gateway
cat > prod/ingress/api-gateway.yaml <<EOF
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: api-gateway-ingress
  namespace: simon-prod
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
    nginx.ingress.kubernetes.io/rewrite-target: /\$2
spec:
  ingressClassName: nginx
  rules:
  - host: ${AZURE_DNS}
    http:
      paths:
      - path: /api(/|$)(.*)
        pathType: ImplementationSpecific
        backend:
          service:
            name: api-gateway-client-service
            port:
              number: 3003
EOF

echo "‚úì Ingress cr√©√©s pour ArgoCD, Prometheus, Grafana, Frontend et API Gateway"
echo "‚úì Tous les fichiers Ingress sauvegard√©s dans prod/ingress/"
echo ""

# Attendre que les Ingress soient pr√™ts
echo "‚è±Ô∏è  Attente de la configuration des Ingress (10 secondes)..."
sleep 10

# V√©rifier les Ingress cr√©√©s
echo "Ingress configur√©s:"
kubectl get ingress -A

echo ""
echo "======================================"
echo "Setup production termin√©!"
echo "======================================"
echo ""
echo "Infrastructure install√©e :"
echo "  ‚úì kubectl"
echo "  ‚úì Minikube (driver: docker)"
echo "  ‚úì Helm"
echo "  ‚úì nginx-ingress (hostNetwork - ports 80/443 sur l'h√¥te)"
echo "  ‚úì ArgoCD + ArgoCD Image Updater"
echo "  ‚úì Prometheus + Grafana"
echo ""
echo "======================================"
echo "Acc√®s aux services (Port 80)"
echo "======================================"
echo ""
echo "üîß ArgoCD (GitOps):"
echo "   URL:      http://${AZURE_DNS}/argocd"
echo "   Username: admin"
echo "   Password: $ARGOCD_PASSWORD"
echo ""
echo "üìä Prometheus (M√©triques):"
echo "   URL:      http://${AZURE_DNS}/prometheus"
echo ""
echo "üìà Grafana (Dashboards):"
echo "   URL:      http://${AZURE_DNS}/grafana"
echo "   Username: admin"
echo "   Password: admin"
echo ""
echo "üåê Applications (apr√®s d√©ploiement via ArgoCD):"
echo "   Frontend:    http://${AZURE_DNS}/"
echo "   API Gateway: http://${AZURE_DNS}/api"
echo ""
echo "‚ö†Ô∏è  Ports ouverts requis sur Azure NSG:"
echo "  - Port 80  (HTTP) ‚úì"
echo "  - Port 443 (HTTPS) ‚úì"
echo ""
echo "======================================"
echo "Namespaces cr√©√©s"
echo "======================================"
echo "  - argocd        (ArgoCD et Image Updater)"
echo "  - monitoring    (Prometheus, Grafana, AlertManager)"
echo "  - simon-prod    (Vos applications)"
echo ""
echo "======================================"
echo "Prochaines √©tapes"
echo "======================================"
echo "  1. ‚úì Ports 80 et 443 d√©j√† ouverts dans votre NSG Azure"
echo "  2. Connectez-vous √† ArgoCD: http://${AZURE_DNS}/argocd"
echo "  3. Configurez vos credentials Docker Hub (si images priv√©es):"
echo "     kubectl create secret docker-registry dockerhub-secret \\"
echo "       --docker-server=https://registry-1.docker.io \\"
echo "       --docker-username=<user> --docker-password=<token> \\"
echo "       -n argocd"
echo "  4. D√©ployez vos applications via ArgoCD"
echo "     - Les fichiers Ingress sont d√©j√† cr√©√©s dans prod/ingress/"
echo "     - Frontend accessible sur: http://${AZURE_DNS}/"
echo "     - API Gateway accessible sur: http://${AZURE_DNS}/api"
echo "  5. Ajoutez les annotations Image Updater pour auto-update"
echo "  6. Consultez Prometheus: http://${AZURE_DNS}/prometheus"
echo "  7. Consultez Grafana: http://${AZURE_DNS}/grafana"
echo ""
echo "Commandes utiles:"
echo "  kubectl get all -n simon-prod         # Voir vos apps"
echo "  kubectl get applications -n argocd    # Apps ArgoCD"
echo "  kubectl get ingress -A                # Voir les Ingress"
echo "  kubectl logs -n argocd -l app.kubernetes.io/name=argocd-image-updater"
echo "  kubectl logs -n ingress-nginx -l app.kubernetes.io/component=controller"
echo "  minikube status                       # Statut de Minikube"
echo ""
