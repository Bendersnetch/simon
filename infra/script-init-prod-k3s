#!/bin/bash

# Script d'installation de l'environnement de production avec k3s
# k3s s'ex√©cute directement sur l'h√¥te (pas dans un conteneur)

# Demander le nom de domaine Azure
echo "======================================"
echo "Initialisation environnement PROD (k3s)"
echo "======================================"
echo ""
read -p "Entrez le nom DNS de votre VM Azure (ex: simon-vm.francecentral.cloudapp.azure.com): " AZURE_DNS
if [ -z "$AZURE_DNS" ]; then
    echo "ERREUR: Le nom DNS est obligatoire"
    exit 1
fi

echo "‚úì Nom DNS configur√©: $AZURE_DNS"
echo ""

# Installer k3s avec Traefik d√©sactiv√© (on utilisera nginx-ingress)
echo "======================================"
echo "Installation de k3s"
echo "======================================"
echo ""

if command -v k3s &> /dev/null; then
    echo "k3s est d√©j√† install√©"
else
    echo "Installation de k3s (n√©cessite sudo)..."
    curl -sfL https://get.k3s.io | sh -s - \
        --write-kubeconfig-mode 644 \
        --disable traefik

    echo "‚úì k3s install√©"
fi

# Configurer kubectl
export KUBECONFIG=/etc/rancher/k3s/k3s.yaml
echo "export KUBECONFIG=/etc/rancher/k3s/k3s.yaml" >> ~/.bashrc

# Attendre que k3s soit pr√™t
echo "Attente que k3s soit pr√™t..."
sleep 15
kubectl wait --for=condition=Ready nodes --all --timeout=60s

echo "‚úì k3s d√©marr√© avec succ√®s"
echo ""

# Installer Helm si non pr√©sent
if ! command -v helm &> /dev/null; then
    echo "Installation de Helm (n√©cessite sudo)..."
    curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | sudo bash
    echo "Helm install√©."
fi

# Ajouter les repos Helm n√©cessaires
helm repo add argo https://argoproj.github.io/argo-helm
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
helm repo update

# Cr√©er namespaces
kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
kubectl create namespace ingress-nginx --dry-run=client -o yaml | kubectl apply -f -
kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -
kubectl create namespace simon-prod --dry-run=client -o yaml | kubectl apply -f -

# Installer nginx-ingress controller avec hostPort (fonctionne nativement sur k3s)
echo "======================================"
echo "Installation de nginx-ingress"
echo "======================================"
echo ""

helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
  --namespace ingress-nginx \
  --set controller.kind=DaemonSet \
  --set controller.hostPort.enabled=true \
  --set controller.hostPort.ports.http=80 \
  --set controller.hostPort.ports.https=443 \
  --set controller.service.type=ClusterIP \
  --wait \
  --timeout 5m

echo "‚úì nginx-ingress install√© (hostPort 80/443 - exposition directe)"
echo ""

# Attendre que nginx soit pr√™t
kubectl wait --namespace ingress-nginx \
  --for=condition=ready pod \
  --selector=app.kubernetes.io/component=controller \
  --timeout=120s

echo "‚úì nginx-ingress pr√™t"
echo ""

# Installer ArgoCD via Helm
echo "======================================"
echo "Installation d'ArgoCD"
echo "======================================"
echo ""

helm upgrade --install argocd argo/argo-cd \
  --namespace argocd \
  --set server.service.type=ClusterIP \
  --set server.insecure=true \
  --set 'server.extraArgs={--basehref=/argocd,--rootpath=/argocd}' \
  --wait

echo "‚úì ArgoCD install√©"
echo ""

# Installer ArgoCD Image Updater via Helm
helm upgrade --install argocd-image-updater argo/argocd-image-updater \
  --namespace argocd \
  --wait

# R√©cup√©rer le mot de passe admin initial d'ArgoCD
ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
echo "ArgoCD install√©. Mot de passe admin initial:"
echo "$ARGOCD_PASSWORD"
echo ""

# Configurer ArgoCD Image Updater pour surveiller les registres d'images
echo "======================================"
echo "Configuration d'ArgoCD Image Updater"
echo "======================================"
echo ""

# Cr√©er une ConfigMap pour configurer les registres √† surveiller
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-image-updater-config
  namespace: argocd
data:
  registries.conf: |
    registries:
    - name: Docker Hub
      api_url: https://registry-1.docker.io
      ping: yes
      credentials: pullsecret:argocd/dockerhub-secret
      default: yes
EOF

echo "‚úì Configuration du registry pour Image Updater"
echo ""

# Installer Prometheus via Helm
echo "======================================"
echo "Installation de Prometheus"
echo "======================================"
echo ""

helm upgrade --install prometheus prometheus-community/kube-prometheus-stack \
  --namespace monitoring \
  --set prometheus.service.type=ClusterIP \
  --set grafana.service.type=ClusterIP \
  --set grafana.adminPassword=admin \
  --wait

echo "‚úì Prometheus et Grafana install√©s"
echo ""

# Cr√©er les ressources Ingress
echo "======================================"
echo "Configuration des Ingress"
echo "======================================"
echo ""

# Cr√©er le dossier ingress dans prod si n√©cessaire
mkdir -p prod/ingress

# Ingress pour ArgoCD
cat > prod/ingress/argocd.yaml <<EOF
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: argocd-server-ingress
  namespace: argocd
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
    nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
spec:
  ingressClassName: nginx
  rules:
  - host: ${AZURE_DNS}
    http:
      paths:
      - path: /argocd
        pathType: Prefix
        backend:
          service:
            name: argocd-server
            port:
              number: 80
EOF

# Appliquer l'Ingress ArgoCD
kubectl apply -f prod/ingress/argocd.yaml

# Ingress pour Prometheus
cat > prod/ingress/prometheus.yaml <<EOF
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: prometheus-ingress
  namespace: monitoring
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
spec:
  ingressClassName: nginx
  rules:
  - host: ${AZURE_DNS}
    http:
      paths:
      - path: /prometheus
        pathType: Prefix
        backend:
          service:
            name: prometheus-kube-prometheus-prometheus
            port:
              number: 9090
EOF

# Appliquer l'Ingress Prometheus
kubectl apply -f prod/ingress/prometheus.yaml

# Ingress pour Grafana
cat > prod/ingress/grafana.yaml <<EOF
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: grafana-ingress
  namespace: monitoring
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
spec:
  ingressClassName: nginx
  rules:
  - host: ${AZURE_DNS}
    http:
      paths:
      - path: /grafana
        pathType: Prefix
        backend:
          service:
            name: prometheus-grafana
            port:
              number: 80
EOF

# Appliquer l'Ingress Grafana
kubectl apply -f prod/ingress/grafana.yaml

# Configurer Grafana pour fonctionner sous /grafana
kubectl set env deployment/prometheus-grafana \
  -n monitoring \
  GF_SERVER_ROOT_URL="http://${AZURE_DNS}/grafana" \
  GF_SERVER_SERVE_FROM_SUB_PATH="true"

echo "‚úì Ingress cr√©√©s pour ArgoCD, Prometheus et Grafana"
echo "‚úì Tous les fichiers Ingress sauvegard√©s dans prod/ingress/"
echo ""

# Attendre que les Ingress soient pr√™ts
echo "‚è±Ô∏è  Attente de la configuration des Ingress (10 secondes)..."
sleep 10

# V√©rifier les Ingress cr√©√©s
echo "Ingress configur√©s:"
kubectl get ingress -A

echo ""
echo "======================================"
echo "Setup production termin√©!"
echo "======================================"
echo ""
echo "Infrastructure install√©e :"
echo "  ‚úì k3s (Kubernetes natif sur l'h√¥te)"
echo "  ‚úì Helm"
echo "  ‚úì nginx-ingress (hostPort - exposition directe sur ports 80/443)"
echo "  ‚úì ArgoCD + ArgoCD Image Updater"
echo "  ‚úì Prometheus + Grafana"
echo ""
echo "======================================"
echo "Acc√®s aux services (Port 80)"
echo "======================================"
echo ""
echo "üîß ArgoCD (GitOps):"
echo "   URL:      http://${AZURE_DNS}/argocd"
echo "   Username: admin"
echo "   Password: $ARGOCD_PASSWORD"
echo ""
echo "üìä Prometheus (M√©triques):"
echo "   URL:      http://${AZURE_DNS}/prometheus"
echo ""
echo "üìà Grafana (Dashboards):"
echo "   URL:      http://${AZURE_DNS}/grafana"
echo "   Username: admin"
echo "   Password: admin"
echo ""
echo "üåê Applications (apr√®s d√©ploiement via ArgoCD):"
echo "   Frontend:    http://${AZURE_DNS}/"
echo "   API Gateway: http://${AZURE_DNS}/api"
echo ""
echo "‚ö†Ô∏è  Ports ouverts requis sur Azure NSG:"
echo "  - Port 80  (HTTP) ‚úì"
echo "  - Port 443 (HTTPS) ‚úì"
echo ""
echo "======================================"
echo "Namespaces cr√©√©s"
echo "======================================"
echo "  - argocd        (ArgoCD et Image Updater)"
echo "  - monitoring    (Prometheus, Grafana, AlertManager)"
echo "  - simon-prod    (Vos applications)"
echo ""
echo "======================================"
echo "V√©rifications"
echo "======================================"
echo ""
echo "Nginx √©coute sur les ports 80/443 :"
sudo ss -tulpn | grep -E ':(80|443) ' || echo "‚ö†Ô∏è  Nginx ne semble pas √©couter sur 80/443"
echo ""
echo "Tous les pods :"
kubectl get pods -A
echo ""
echo "======================================"
echo "Prochaines √©tapes"
echo "======================================"
echo "  1. ‚úì Ports 80 et 443 d√©j√† ouverts dans votre NSG Azure"
echo "  2. Connectez-vous √† ArgoCD: http://${AZURE_DNS}/argocd"
echo "  3. Configurez vos credentials Docker Hub (si images priv√©es):"
echo "     kubectl create secret docker-registry dockerhub-secret \\"
echo "     --docker-server=https://registry-1.docker.io \\"
echo "     --docker-username=<user> --docker-password=<token> \\"
echo "     -n argocd"
echo "  4. D√©ployez vos applications via ArgoCD"
echo "  5. Consultez Prometheus: http://${AZURE_DNS}/prometheus"
echo "  6. Consultez Grafana: http://${AZURE_DNS}/grafana"
echo ""
echo "Commandes utiles:"
echo "  kubectl get all -n simon-prod         # Voir vos apps"
echo "  kubectl get applications -n argocd    # Apps ArgoCD"
echo "  kubectl get ingress -A                # Voir les Ingress"
echo "  kubectl logs -n argocd -l app.kubernetes.io/name=argocd-image-updater"
echo "  kubectl logs -n ingress-nginx -l app.kubernetes.io/component=controller"
echo "  systemctl status k3s                  # Statut de k3s"
echo ""
